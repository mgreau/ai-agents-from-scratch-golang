# Messages & Types

**Part 1: Foundation - Lesson 2**

> Structuring conversation data for AI agents in Go

## Overview

In Lesson 1, you learned about Runnables - the foundation of composability. Now we'll explore how to structure the *data* that flows through these Runnables, specifically for conversational AI systems.

Messages are the lingua franca of AI agents. They provide a standardized way to represent conversations, tool calls, system instructions, and more. By the end of this lesson, you'll understand why proper message typing is crucial for building reliable agents.

## Why Does This Matter?

### The Problem: Unstructured Conversations

Imagine building a chatbot without message types:

```go
// Bad: Everything is just strings
conversation := []string{
    "You are a helpful assistant",
    "What's the weather?",
    "The weather is sunny",
    "Thanks!",
}

// Questions:
// - Which messages are from the user?
// - Which are from the AI?
// - Which is the system instruction?
// - How do we handle tool calls?
// - What about metadata like timestamps?
```

This quickly becomes unmaintainable. You can't tell who said what, when, or why.

### The Solution: Typed Messages

```go
// Good: Structured message types
conversation := []Message{
    NewSystemMessage("You are a helpful assistant", nil),
    NewHumanMessage("What's the weather?", nil),
    NewAIMessage("The weather is sunny", nil),
    NewHumanMessage("Thanks!", nil),
}

// Now we can:
// - Filter by message type
// - Format differently for display
// - Track metadata automatically
// - Handle tool calls properly
// - Validate conversation structure
```

## Learning Objectives

By the end of this lesson, you will:

- ✅ Understand the four core message types
- ✅ Implement a type-safe message system with Go interfaces
- ✅ Add metadata and timestamps automatically
- ✅ Format messages for LLM consumption
- ✅ Build a conversation history manager
- ✅ Handle special message types (tool calls, function results)
- ✅ Use JSON marshaling for persistence

## Core Message Types

Every conversational AI system needs these four fundamental message types:

### 1. SystemMessage

**Purpose**: Instructions that shape the AI's behavior

**Characteristics**:
- Always at the start of conversations
- Not visible to end users
- Defines the AI's role, personality, constraints
- Typically set by developers, not users

**Go Implementation**:
```go
system := NewSystemMessage(
    "You are a helpful Python programming tutor. "+
    "Explain concepts clearly with code examples. "+
    "Always encourage learning.",
    nil,
)
```

**When to use**:
- Setting AI personality
- Defining response format
- Adding constraints or rules
- Providing context

### 2. HumanMessage

**Purpose**: Input from the user/human

**Characteristics**:
- User questions, commands, or statements
- What the AI should respond to
- Can contain multiple paragraphs
- May include context or files

**Go Implementation**:
```go
human := NewHumanMessage(
    "How do I reverse a string in Go?",
    nil,
)
```

**When to use**:
- User input in chatbots
- Queries to agents
- Commands to execute

### 3. AIMessage

**Purpose**: Responses from the AI/assistant

**Characteristics**:
- The AI's text responses
- Can include reasoning, answers, questions
- May contain tool calls (function requests)
- Generated by the LLM

**Go Implementation**:
```go
ai := NewAIMessage(
    "Here's how to reverse a string in Go:\n\n"+
    "```go\ntext := \"hello\"\n"+
    "runes := []rune(text)\n"+
    "for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n"+
    "    runes[i], runes[j] = runes[j], runes[i]\n"+
    "}\n"+
    "reversed := string(runes)\n```",
    nil,
)
```

**When to use**:
- LLM responses
- Agent outputs
- Generated text

### 4. ToolMessage

**Purpose**: Results from tool/function execution

**Characteristics**:
- Returns data from external functions
- Links back to the AI's tool call
- Often structured data (JSON)
- Input for AI's next response

**Go Implementation**:
```go
toolResult := NewToolMessage(
    `{"temperature": 72, "condition": "sunny"}`,
    "tool_call_123", // links to AI's tool call ID
    nil,
)
```

**When to use**:
- Returning function results to the AI
- Providing external data
- Completing tool calls

## Message Flow in Conversations

Here's how messages typically flow in an agent conversation:

```
1. System    → "You are a helpful assistant with access to a calculator"
2. Human     → "What's 123 * 456?"
3. AI        → [Calls calculator tool with 123, 456]
4. Tool      → [Returns 56088]
5. AI        → "The result of 123 * 456 is 56,088"
6. Human     → "Thanks!"
7. AI        → "You're welcome!"
```

## Implementation in Go

Let's build our message system using Go's type system.

### Step 1: The Message Interface

**Location:** `pkg/core/message.go`

```go
package core

import (
    "encoding/json"
    "fmt"
    "math/rand"
    "time"
)

// MessageType represents the type of message
type MessageType string

const (
    MessageTypeSystem MessageType = "system"
    MessageTypeHuman  MessageType = "human"
    MessageTypeAI     MessageType = "ai"
    MessageTypeTool   MessageType = "tool"
)

// Message is the base interface for all message types
type Message interface {
    GetContent() string
    GetType() MessageType
    GetID() string
    GetTimestamp() int64
    ToJSON() ([]byte, error)
    ToPromptFormat() map[string]interface{}
    String() string
}
```

**Why this design?**
- Type-safe with const enums
- Interface allows polymorphism
- Easy to add new message types
- JSON serialization built-in

### Step 2: Base Message Struct

```go
// BaseMessage contains common functionality
type BaseMessage struct {
    ID                string                 `json:"id"`
    Content           string                 `json:"content"`
    Timestamp         int64                  `json:"timestamp"`
    AdditionalKwargs  map[string]interface{} `json:"additional_kwargs,omitempty"`
}

// NewBaseMessage creates a new base message
func NewBaseMessage(content string, kwargs map[string]interface{}) *BaseMessage {
    if kwargs == nil {
        kwargs = make(map[string]interface{})
    }
    return &BaseMessage{
        ID:               generateMessageID(),
        Content:          content,
        Timestamp:        time.Now().UnixMilli(),
        AdditionalKwargs: kwargs,
    }
}

func (m *BaseMessage) GetContent() string {
    return m.Content
}

func (m *BaseMessage) GetID() string {
    return m.ID
}

func (m *BaseMessage) GetTimestamp() int64 {
    return m.Timestamp
}

// generateMessageID generates a unique message ID
func generateMessageID() string {
    timestamp := time.Now().UnixMilli()
    random := rand.Intn(1000000)
    return fmt.Sprintf("msg_%d_%d", timestamp, random)
}
```

**Go patterns used:**
- Struct embedding for composition
- JSON tags for serialization
- Builder pattern for creation
- Automatic ID and timestamp generation

### Step 3: Specific Message Types

```go
// SystemMessage represents instructions for the AI
type SystemMessage struct {
    *BaseMessage
}

func NewSystemMessage(content string, kwargs map[string]interface{}) *SystemMessage {
    return &SystemMessage{
        BaseMessage: NewBaseMessage(content, kwargs),
    }
}

func (m *SystemMessage) GetType() MessageType {
    return MessageTypeSystem
}

func (m *SystemMessage) ToPromptFormat() map[string]interface{} {
    return map[string]interface{}{
        "role":    "system",
        "content": m.Content,
    }
}

func (m *SystemMessage) String() string {
    t := time.UnixMilli(m.Timestamp)
    return fmt.Sprintf("[%s] system: %s", t.Format("15:04:05"), m.Content)
}

func (m *SystemMessage) ToJSON() ([]byte, error) {
    data := map[string]interface{}{
        "id":        m.ID,
        "type":      m.GetType(),
        "content":   m.Content,
        "timestamp": m.Timestamp,
    }
    for k, v := range m.AdditionalKwargs {
        data[k] = v
    }
    return json.Marshal(data)
}
```

**Similar implementations for HumanMessage and AIMessage...**

### Step 4: AIMessage with Tool Calls

AIMessage is special because it can request tool execution:

```go
// ToolCall represents a request to execute a function
type ToolCall struct {
    ID       string                 `json:"id"`
    Type     string                 `json:"type"`
    Function ToolCallFunction       `json:"function"`
}

type ToolCallFunction struct {
    Name      string `json:"name"`
    Arguments string `json:"arguments"` // JSON string
}

// AIMessage with tool call support
type AIMessage struct {
    *BaseMessage
    ToolCalls []ToolCall `json:"tool_calls,omitempty"`
}

func NewAIMessage(content string, kwargs map[string]interface{}) *AIMessage {
    msg := &AIMessage{
        BaseMessage: NewBaseMessage(content, kwargs),
        ToolCalls:   []ToolCall{},
    }
    
    // Extract tool calls from kwargs if present
    if toolCalls, ok := kwargs["tool_calls"]; ok {
        if tc, ok := toolCalls.([]ToolCall); ok {
            msg.ToolCalls = tc
        }
    }
    
    return msg
}

func (m *AIMessage) GetType() MessageType {
    return MessageTypeAI
}

func (m *AIMessage) HasToolCalls() bool {
    return len(m.ToolCalls) > 0
}

func (m *AIMessage) ToPromptFormat() map[string]interface{} {
    result := map[string]interface{}{
        "role":    "assistant",
        "content": m.Content,
    }
    
    if m.HasToolCalls() {
        result["tool_calls"] = m.ToolCalls
    }
    
    return result
}
```

### Step 5: Helper Functions

```go
// MessagesToPromptFormat converts messages for LLM consumption
func MessagesToPromptFormat(messages []Message) []map[string]interface{} {
    result := make([]map[string]interface{}, len(messages))
    for i, msg := range messages {
        result[i] = msg.ToPromptFormat()
    }
    return result
}

// FilterMessagesByType filters messages by type
func FilterMessagesByType(messages []Message, msgType MessageType) []Message {
    var filtered []Message
    for _, msg := range messages {
        if msg.GetType() == msgType {
            filtered = append(filtered, msg)
        }
    }
    return filtered
}

// GetLastMessages returns the last N messages
func GetLastMessages(messages []Message, n int) []Message {
    if n >= len(messages) {
        return messages
    }
    return messages[len(messages)-n:]
}
```

## Practical Examples

### Example 1: Building a Conversation

```go
func buildConversation() []Message {
    return []Message{
        NewSystemMessage("You are a helpful coding assistant", nil),
        NewHumanMessage("How do I read a file in Go?", nil),
        NewAIMessage("Use os.ReadFile() or os.Open() with bufio.Scanner", nil),
        NewHumanMessage("Show me an example", nil),
        NewAIMessage(
            "```go\n"+
            "data, err := os.ReadFile(\"file.txt\")\n"+
            "if err != nil {\n"+
            "    log.Fatal(err)\n"+
            "}\n"+
            "fmt.Println(string(data))\n"+
            "```",
            nil,
        ),
    }
}
```

### Example 2: Conversation with Tool Calls

```go
func conversationWithTools() []Message {
    // 1. Human asks question
    messages := []Message{
        NewSystemMessage("You have access to a calculator", nil),
        NewHumanMessage("What's 156 * 789?", nil),
    }
    
    // 2. AI requests tool
    aiMsg := NewAIMessage("Let me calculate that for you", map[string]interface{}{
        "tool_calls": []ToolCall{{
            ID:   "call_123",
            Type: "function",
            Function: ToolCallFunction{
                Name:      "calculator",
                Arguments: `{"operation": "multiply", "a": 156, "b": 789}`,
            },
        }},
    })
    messages = append(messages, aiMsg)
    
    // 3. Tool returns result
    toolMsg := NewToolMessage("123084", "call_123", nil)
    messages = append(messages, toolMsg)
    
    // 4. AI responds with answer
    finalMsg := NewAIMessage("156 * 789 = 123,084", nil)
    messages = append(messages, finalMsg)
    
    return messages
}
```

### Example 3: Persisting Conversations

```go
func saveConversation(messages []Message, filename string) error {
    // Convert to JSON
    data := make([]json.RawMessage, len(messages))
    for i, msg := range messages {
        msgJSON, err := msg.ToJSON()
        if err != nil {
            return err
        }
        data[i] = msgJSON
    }
    
    // Marshal array
    output, err := json.MarshalIndent(data, "", "  ")
    if err != nil {
        return err
    }
    
    // Save to file
    return os.WriteFile(filename, output, 0644)
}

func loadConversation(filename string) ([]Message, error) {
    // Read file
    data, err := os.ReadFile(filename)
    if err != nil {
        return nil, err
    }
    
    // Parse JSON
    var rawMessages []map[string]interface{}
    if err := json.Unmarshal(data, &rawMessages); err != nil {
        return nil, err
    }
    
    // Convert to Message types
    messages := make([]Message, len(rawMessages))
    for i, raw := range rawMessages {
        msgType := MessageType(raw["type"].(string))
        content := raw["content"].(string)
        
        switch msgType {
        case MessageTypeSystem:
            messages[i] = NewSystemMessage(content, nil)
        case MessageTypeHuman:
            messages[i] = NewHumanMessage(content, nil)
        case MessageTypeAI:
            messages[i] = NewAIMessage(content, nil)
        case MessageTypeTool:
            toolCallID := raw["tool_call_id"].(string)
            messages[i] = NewToolMessage(content, toolCallID, nil)
        }
    }
    
    return messages, nil
}
```

## Exercises

### Exercise 5: Message Formatter
Build a formatter that displays messages nicely for the console.
- [Starter Code](exercises/05-message-formatter/starter.go)
- [Solution](exercises/05-message-formatter/solution.go)

### Exercise 6: Conversation Validator
Create a validator that checks conversation structure is valid.
- [Starter Code](exercises/06-conversation-validator/starter.go)
- [Solution](exercises/06-conversation-validator/solution.go)

### Exercise 7: Chat History Manager
Implement a history manager with size limits.
- [Starter Code](exercises/07-chat-history/starter.go)
- [Solution](exercises/07-chat-history/solution.go)

### Exercise 8: Tool Flow Handler
Build a handler for tool call → result → response flow.
- [Starter Code](exercises/08-tool-flow/starter.go)
- [Solution](exercises/08-tool-flow/solution.go)

## Key Takeaways

1. ✅ **Four message types** - System, Human, AI, Tool
2. ✅ **Interface-based design** - Type-safe polymorphism
3. ✅ **Automatic metadata** - IDs and timestamps
4. ✅ **JSON serialization** - Easy persistence
5. ✅ **ToPromptFormat()** - LLM-ready conversion
6. ✅ **Tool call support** - Function calling built-in
7. ✅ **Helper functions** - Filtering, formatting, conversion

## What's Next

**Next Lesson**: [03-llm-wrapper](../03-llm-wrapper/lesson.md) - Wrapping go-llama.cpp as a Runnable

**See it in action**: Check `pkg/core/message.go` for the full implementation

**Practice**: Complete all 4 exercises before moving on

## Further Reading

- [JSON in Go](https://go.dev/blog/json)
- [Interface Patterns](https://go.dev/doc/effective_go#interfaces)
- [OpenAI Message Format](https://platform.openai.com/docs/api-reference/chat)
